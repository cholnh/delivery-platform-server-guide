# MSA 패턴

<br/><br/>



## :speech_balloon: 개요
앞에서 설명한 아키텍처는 문제 영역에 대한 솔루션을 제공하는 것입니다.  
그렇다면 어떤 문제영역이 있고 어떤 해법으로 그 문제를 해결할까요?  

<br/>

이처럼 어떤 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 유용한 해법을 패턴(Pattern)이라고 합니다.  
MSA 에도 이러한 설계 패턴들이 존재합니다.  

<br/>

MSA 를 통해 서비스를 제공하려면 우선은 인프라가 구축돼야 하고,  
그 위에 미들웨어가 올라가고, 미들웨어 위에서 어플리케이션이 동작해야 합니다.  

|패턴 유형|설명|
|-|-|
|인프라 구성요소|마이크로 서비스를 지탱하는 하부구조 인프라를 구축하는 데 필요한 구성요소|
|플랫폼 패턴|인프라 위에서 마이크로 서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴|
|어플리케이션 패턴|마이크로 서비스 어플리케이션을 구성하는 데 필요한 패턴|

<br/>

마이크로 서비스가 동작하고 운영되는 그릇인 외부 아키텍처를 중심으로, 시스템의 기반을 지탱하는 인프라 구성 요소부터 살펴보겠습니다.

<br/><br/>

## 인프라 구성요소
인프라란 엔터프라이즈 IT 환경을 운영/관리하는 데 필요한 근간이 되는
- 하드웨어
- 소프트웨어
- 네트워크 구성요소
- 운영체제
- 데이터 스토리지 등

을 모두 포괄하는 영역입니다.

<br/>

> 클라우드 환경에서는 이러한 인프라 구성요소가 가상화되어 제공됩니다.

<br/><br/>

### 클라우드 환경
예전에 오랜 시간에 걸쳐 힘들게 구축했던 인프라를 이제는 AWS, 구글, 마이크로소프트, IBM 등 세계적인 플랫폼 사업자들이 
자동화된 Iaas (Infrastructure as a Service), Paas (Platform as a Service) 서비스를 통해 쉽고 편하게 이용할 수 있게 해줍니다.

<br/>

시스템의 자원 구성, 할당, 관리, 모니터링 등의 설정작업을 몇 번의 클릭만으로 가능하게 합니다.  
하지만 클라우드 환경에서도 아키텍트가 고려해야 할 일들은 여러가지가 있습니다.  

- 하부 시스템의 기반이 되는 인프라 구축
- 베어 메탈 장비에 인프라를 구축할지, 가상화 환경을 선택할지 결정
- 가상화 환경에서 퍼블릭 Iaas, PaaS 를 선택할지, 직접 구매할지, 베어 메탈 서버에 프라이빗 PaaS 를 구축할지 결정

<br/>

마이크로 서비스는 어떠한 장비에도 구동될 수 있습니다.  
그렇지만 가상화 장치 없이 구동한다면 인프라의 유연한 확장/축소를 기대하기 힘든 무모한 작업이 됩니다.  
(MSA 시스템을 위한 베어 메탈을 고려한다면 그것은 베어 메탈에 별도의 프라이빗 클라우드 환경을 구축하는 것을 의미합니다)  
따라서 MSA 는 가상 인프라 환경을 환경을 이용하는 것이 효율적입니다.  

<br/>

인프라를 선택하였다면, 다음으로 가상머신과 컨테이너 기반 제품을 고민해보겠습니다.

### VM과 컨테이너
두 기술 모두 가상의 공간을 만들어내는 공통점이 있습니다.  
하지만 자세하게 살펴보면 완전히 다른 점들이 있습니다.  

- 가상머신(VM; Virtual Machine)  
    하이퍼바이저(Hypervisor)라는 소프트웨어를 이용해 하나의 시스템에서 여러 개의 OS(운영체제)를 사용하는 기술  
    + 일반적으로 크기가 기가바이트 단위
    + 게스트 OS 를 사용하기에 OS 패치 설치, 라이브러리 설치 등 오버헤드가 지속적으로 발생
    
<br/>
    
- 컨테이너  
    하이퍼바이저 없이 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성  
    + 일반적으로 크기가 메가바이트 단위
    + 작은 서비스를 패키징하고 배포하기에 적합 (실행에 필요한 모든 파일이 컨테이너에 패키징 되지 않음)

<br/>

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-vm-container.png" width="600"/>|
|-|
|그림 1 - 가상 머신과 컨테이너|

MSA 에서는 작은 서비스 단위로 잦은 배포가 이루어지므로 컨테이너 환경이 유리합니다.  
마이크로 서비스의 가변적이고 유연한 속성을 컨테이너가 쉽고 빠르게 지원할 수 있기 때문입니다.  
가장 대표적인 컨테이너 기술로는 도커가 있습니다.
도커에 관한 설명은 [이곳을](https://github.com/cholnh/delivery-platform-server-guide/blob/main/contents/3/msa-docker.md#도커) 참조해주세요.

<br/><br/>

### 컨테이너 오케스트레이션
도커 외에도 Unikernels, LXD, OpenVZ, RKt 등 컨테이너 기술들이 있습니다.  
컨테이너 기술을 선택하셨다면 컨테이너를 관리하기 위한 기술 또한 필요합니다.  

<br/>

#### 왜 필요한가?
컨테이너가 많아지면 그에 따른 관리가 필연적입니다.  
- 컨테이너의 자동 배치 및 복제
- 컨테이너 장애 복구
- 컨테이너 확장 및 축소
- 컨테이너 간 통신 관리
- 로드 밸런싱 등

이 밖에도 여러 필요에 따른 관리 기술들이 필요해집니다.  

<br/>

이러한 컨테이너 관리 기술을 통틀어 컨테이너 오케스트레이션 이라 합니다.  
오케스트레이션 도구로는 Docker Swarm, Apache Mesos,  
그리고 최근 구글이 자사의 도커 컨테이너 관리 노하우를 바탕으로 만든 Kubernetes 가 있습니다.  
쿠버네티스에 관한 설명은 [이곳을](https://github.com/cholnh/delivery-platform-server-guide/blob/main/contents/3/msa-kubernetes.md#쿠버네티스) 참조해주세요.

<br/><br/>

### 클라우드 인프라 서비스
클라우드 인프라 선택지는 매우 다양합니다.  
위 클라우드 환경에서 설명하였듯이 여러 사업자들이 많은 인프라 시스템을 제공합니다.  
- AWS
- Azure
- Google Cloud 등

<br/>

MSA 시스템으로 간다고 하면 쿠버네티스는 아니지만 동일하게 컨테이너 기반인
- AWS Elastic Beanstalk
- Elastic Container Service(ECS)
- Azure Web App
- Google App Engine 등
여러 PaaS 를 고려할 수 있습니다.

> PaaS(Platform as a Service) : 복잡함 없이 어플리케이션을 곧바로 개발, 실행, 관리할 수 있는 플랫폼 환경을 서비스 형태로 제공합니다. 
> IaaS 위에 미들웨어나 런타임까지 탑재된 환경이라 생각하면 됩니다.

<br/>

여기까지 마이크로 서비스를 적재하기 위한 기반이 되는 클라우드 인프라 요소를 살펴보았습니다.  
다음으로는 마이크로 서비스의 원활한 동작을 지원하는 플랫폼 환경을 살펴보겠습니다.

<br/><br/>

## 플랫폼 패턴
인프라 환경 위에서 어플리케이션을 운영/관리/빌드/배포하는 환경을 구성하는 방법을 생각해봐야 합니다.  

> 마틴 파울러가 강조했듯이 MSA 시스템을 구성하는 수많은 마이크로 서비스를 하나하나 수동으로 빌드/배포한다면 엄청나게 비효율적입니다. 
> 이러한 과정을 하나하나 통제하고 자동화하는 것이 중요합니다.

<br/><br/>

### 데브옵스 인프라 구성
마이크로 서비스를 (자동으로) 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경을 데브옵스(DevOps)환경이라 합니다.
(보통 개발+운영 을 병행하는 조직 또는 문화를 뜻하는데, 여기서는 자동화 환경의 의미로 사용하겠습니다)

<br/>

과거 수동 빌드/배포 과정은 매우 많은 시간이 소요되었습니다.  
또한 배포 때마다 시스템을 중단한 뒤 배포 작업을 진행하는 경우가 많았습니다.  
하지만 MSA 환경에서는 잦은 배포가 이루어져야 하므로 배포의 자동화와 무중단 배포가 절실합니다.

<br/>

자동화된 빌드/배포 작업은 CI/CD 라 합니다.  
- CI (Continuous Integration; 지속적 통합)  
    오랜 시간이 걸리는 빌드를 자동화하여 개발 생산성과 소스코드 품질을 높입니다.  
    자동으로 통합 및 테스트하고 그 결과를 리포트로 기록합니다.
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-cicd.png" width="700"/>|
    |-|
    |그림 2 - 자동 빌드 및 배포 절차|
    
<br/>
    
- CD (Continuous Deployment; 지속적 배포)  
    소스코드 저장소에서 빌드한 소스코드의 실행 파일을 실행 환경까지 자동으로 배포하는 방식을 뜻합니다.  
    다른 의미의 CD (지속적 제공; Continuous Delivery) 와의 차이는 엄격한 배포 절차에 있습니다.
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-cd-diff.png" width="500"/>|
    |-|
    |그림 3 - Continuous Deployment 와 Continuous Delivery 차이|

<br/><br/>

### 빌드/배포 파이프라인 설계
빌드/배포 과정 동안 수행해야 할 테스크가 정의된 것을 빌드/배포 파이프라인이라고 합니다.  

<br/>

전형적인 파이프라인 흐름도는 다음과 같습니다.  

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-cicd-pipeline.png" width="700"/>|
|-|
|그림 3 - 배포 파이프라인 절차|

배포 절차 전에 UI 테스트, 통합테스트, 배포 승인 프로세스 등을 추가하여 재설계할 수도 있습니다.  
위와 같은 일련의 프로세스를 하나로 연계해서 자동화하고 시각화한 절차로 구축합니다.

<br/>

#### Infrastructure as Code
인프라 구성을 마치 프로그래밍하는 것처럼 처리하여 소수의 인원으로 많은 컨테이너 배포 처리를 하는 것을 뜻합니다.  

- 배포 파이프라인 절차를 완벽하게 자동화
- 대규모 인프라 관리
- 쉬운 공유/재사용

<br/>

Infrastructure as Code 를 통해 자동화할 요소들로는 다음과 같습니다.

- 형상관리 리포지토리에서 소스코드를 가져와 빌드하여 실행 파일을 만드는 작업
- 실행 파일을 실행 환경에 배포하는 작업
- 연계 자동화 작업 (위 작업들을 통제/연결하여 전 작업이 성공하면 다음 작업이 자동으로 수행)

<br/>

위 요소들을 모두 코드로 정의/설정할 수 있고 이를 지원하는 여러 오픈소스나 솔루션이 있습니다.  
MSA 서비스 마다 각자 다른 빌드/배포 파이프라인을 설계하고 자동/수동화를 적용할 수 있습니다.  

<br/><br/>

### 마이크로 서비스 생태계
마이크로 서비스가 어떻게 발전했는지 흐름을 살펴보겠습니다.

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-history.png" width="800"/>|
|-|
|그림 4 - 마이크로 서비스 발전 히스토리|

<br/>

이전 설명했던 CI (지속적 통합) 개념이 켄트 벡에 의해 XP 방법론의 프랙티스로 소개됩니다.  
그 후 켄트 벡, 켄 슈와버, 마틴 파울러 등 여러 구루들이 모여 2001년 **'애자일 선언'** 을 하게 됩니다.  
장기적인 계획이나 단계적 프로세스로 개발을 해온 소프트웨어 업계에 변화의 바람이 불기 시작합니다.  
빠른 실패와 빠른 피드백을 기반으로 하는 애자일의 실용적인 실천법으로 개발 흐름이 점점 변화하게 됩니다.

<br/>

2006년 아마존의 IaaS 서비스인 EC2 를 시장에 최초로 발표하며 대 클라우드 시대가 열리게 됩니다.  
그즈음 (DVD 대여 서비스로 출발했던) 넷플릭스가 스트리밍 사업을 시작하게 되는데, 스트리밍 데이터베이스의 스토리지가 손실되는 대규모 서비스 장애를 겪게 됩니다.  
이를 계기로 넷플릭스는 기존 (한 덩어리의) 모노리스 시스템에서 마이크로 서비스 시스템으로 전환하는 작업을 시작하게 됩니다.  
(이때 선택한 클라우드가 AWS EC2 입니다)

<br/>

넷플릭스는 마이크로 서비스 전환 과정을 거치면서 여러 풍파를 겪게 됩니다. 
- 기존 모노리스 시스템에서는 고려하지 않아도 될 문제점들이 점점 발생
- 발생 장애가 다른 서비스에게 전파
- 여러 서비스에 분산된 로그 관리 문제
- 장애 모니터링 등

넷플릭스는 경험에 기반한 문제해결 도구를 개발하게 됩니다.  
그리고 넷플릭스 기술력에 의구심을 갖는 사람들에게 보란듯이 오픈소스로 공개합니다.  
그것이 바로 넷플릭스 OSS 입니다.

<br/>

넷플릭스 OSS 는 여러 마이크로 서비스 운영 환경을 위한 서비스를 제공합니다.
- 마이크로 서비스 간의 라우팅과 로드 밸렁신을 위한 줄(Zuul) 과 리본(Ribbon)
- 모니터링을 위한 히스트릭스(Hystrix)
- 서비스 등록/디스커버리를 위한 유레카(Eureka) 등

이러한 오픈소스를 통해 기술들이 공유되며 마이크로 서비스 업계가 빠르게 발전되게 됩니다.

<br/>

이후 2013년 컨테이너 기술인 도커가 등장하게 됩니다.  
또한 이쯤에 스프링 진영에서 마이크로 서비스를 쉽게 개발할 수 있는 프레임워크인 스프링 부트를 발표합니다.  
최근 구글에서는 컨테이너 오케스트레이션 기술인 쿠버네티스 까지 등장하게 됩니다.  
이러한 수많은 과정들을 거쳐 마이크로 서비스는 계속 끊임없이 발전되고 있습니다.

<br/>

위 발전 흐름을 통해 생겨난 문제 해결 패턴들이 존재합니다.
그 패턴들을 하나하나 알아보겠습니다.

<br/><br/>

### 마이크로 서비스 관리/운영 패턴
마이크로 서비스 구축 시 발생하는 문제는 주로 여러 개의 시스템 구성 방식 때문에 발생하게 됩니다.  
앞에서 언급했다시피 넷플릭스는 이러한 문제를 해결하는 데 크게 기여했습니다.  

<br/>

넷플릭스 OSS 는
- API 게이트웨이
- 서비스 디스커버리
- 모니터링
- 트레이싱 등

다수의 마이크로 서비스를 관리/운영하기 위한 플랫폼 패턴을 제공합니다.
또한 스프링 진영에서는 기존 스프링 부트 프레임워크에 넷플릭스 OSS 가 잘 작동하도록,  
넷플릭스 OSS 모듈들을 감싸 스프링 클라우드(Spring Cloud) 라는 명칭으로 내놓았습니다.

<br/>

스프링 부트와 스프링 클라우드를 이용하면 마이크로 서비스 어플리케이션 운영 환경을 쉽게 구축할 수 있게 됩니다.  
이어서 스프링 클라우드를 중심으로 주요 관리/운영 플랫폼 패턴을 살펴보겠습니다.

<br/><br/>

### 스프링 클라우드
스프링 클라우드는 넷플릭스 OSS(Zuul, Eureka, Hystrix, Ribbon 등)를 스프링 프레임워크 기반으로 사용하기 쉽게 통합한 것입니다.  

<br/>

스프링 클라우드 기반으로 동작하는 서비스 연계 흐름은 다음과 같습니다.

1. 환경 설정 정보를 형상관리 시스템에 연계된 Config 서비스에서 가져와 설정 정보를 주입 후 클라우드 인프라의 개별 인스턴스로 로딩.  
    + 모든 마이크로 서비스를 인프라에 종속되지 않도록 설정파일을 분리
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-1.png" width="600"/>|
    |-|
    |설정 정보 주입|

<br/>

2. 로딩과 동시에 '서비스 레지스트리'에 자신의 서비스명과 클라우드 인프라로 부터 할당받은 물리 주소를 매핑해서 등록.  

    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-2.png" width="600"/>|
    |-|
    |서비스 등록|
    
<br/>
        
3. 클라이언트가 'API 게이트웨이'를 통해 마이크로 서비스에 접근하고, 이때 API 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드 밸런싱 추가.

    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-3.png" width="600"/>|
    |-|
    |API 게이트웨이|
    
<br/>

4. API 게이트웨이에서 클라이언트가 마이크로 서비스에 접근하기 위한 주소를 알기 위해 '서비스 레지스트리' 검색을 통해 서비스의 위치 반환.

    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-4.png" width="600"/>|
    |-|
    |서비스 디스커버리|
    
<br/>

5. 동시에 API 게이트웨이는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 '인증 서비스'와 연계하여 인증/인가 처리를 수행. 

    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-5.png" width="600"/>|
    |-|
    |서비스 인증/인가|
    
<br/>

6. 이러한 모든 마이크로 서비스 간의 호출 흐름은 '모니터링 서비스'와 '추적 서비스'에 의해 모니터링/추적 됩니다.

    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-6.png" width="600"/>|
    |-|
    |모니터링/추적|
    
<br/><br/>

전체 아키텍처는 다음과 같습니다.

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-service-all.png" width="1100"/>|
|-|
|스프링 클라우드를 기반으로 한 아키텍처 전체 흐름도|

<br/><br/>

### 점점 비대해지는 운영/관리...
위에서 살펴본 `Spring Cloud + Netflix OSS` 패턴은 모두 모노리스 시스템이 여러 조각조각으로 나뉘어져서 발생하는 문제들을 해결합니다.  
하지만 각 문제들마다 상이한 기술들로 해결하므로 해결 자체의 복잡성 또한 증가되고 있습니다.  

<br/>

이후 여러 문제의 해결책을 한꺼번에 제공하는 솔루션들이 등장하게 됩니다.  
바로 쿠버네티스나 오픈시프트와 같은 제품들입니다.  

<br/>

> 특히 인프라 유연성을 보장하기 위해 AWS IaaS 의 인프라 차원에서 해결 했던 역할을 쿠버네티스가 소프트웨어 차원, 
> 즉 컨테이너의 레플리카 기술로 탐색, 호출 문제와 함께 통합해서 지원하면서 쿠버네티스가 각광받고 있습니다.  
> 최근 동향은 쿠버네티스와 덧붙여 이스티오(Istio) 기술이 함께 사용되고 있습니다.

<br/><br/>

### 서비스 메시 패턴
위에서 언급하였듯이 `Spring Cloud + Netflix OSS` 기반의 서비스를 구축/운용할 때의 문제점은  
운영 관리를 위한 여러 개의 기반 서비스를 별도로 각각 만들어야 한다는 번거로움이 있다는 것입니다.  
또한 업무 처리 마이크로 서비스에 **'스프링 클라우드 서비스를 사용하기 위한 라이브러리'** 를 비지니스 로직과 **'함께 탑재'** 해야 한다는 점입니다.  

<br/>



# 마이크로 서비스 어플리케이션 패턴

<br/><br/>



## :speech_balloon: 개요
마이크로 서비스 어플리케이션 영역은 실제로 개발자가 구현해야 할 부분입니다.  
서비스의 비즈니스 로직에 집중할 수 있게

- 유연성
- 확장성
- 독립성 등

을 염두에 두고 설계한 여러 패턴들이 있습니다.

<br/><br/>

### 프론트엔드 연계
우선 하나의 서비스는 보통 프론트엔드와 백엔드의 연계로 구현됩니다.  
만약 프론트엔드가 단일 모노리스로 구성되어있다고 가정한다면,  
MSA 로 구성된 백엔드와의 연계가 매끄럽게 이어지지 않을것입니다.

<br/>

업무 기능 하나가 변경되어 재배포해야 할 상황을 가정해보겠습니다.  
백엔드 부분에서는 수정된 내용이 독립적으로 배포 가능하지만,  
프론트엔드는 하나의 덩어리(모노리스)이기 때문에 변경되지 않은 다른 기능들도 함께 빌드, 배포되어야 합니다.  

<br/>

따라서 이전에 백엔드가 모노리스였을 때 겪었던 문제들
- 독립적인 기능 변경 및 배포 불가
- 독립적인 기능 확장 불가 등

을 프론트엔드의 모노리스 서비스도 동일하게 겪을 수밖에 없습니다.

<br/>

이를 위한 프론트엔드 설계 패턴으로 다음이 있습니다.
- UI 컴포지드 패턴
- 마이크로 프론트엔드 패턴

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-fe.png" width="700"/>|
|-|
|그림 1 - 독립된 팀에서 별도로 관리하는 프론트엔드|

그림 1 과 같이 프론트엔드도 백엔드의 마이크로 서비스처럼 기능별로 분리하고  
이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프론트엔드를 조합해서 동작됩니다.  

<br/>

각각의 마이크로 프론트엔드 조각들은 비즈니스 구현을 위해 여러 개의 백엔드 마이크로 서비스 API 를 호출하게 됩니다.  
하나의 기능을 변경했을 때 이를 제공하는 마이크로 프론트엔드와 백엔드를 구성하는 마이크로 서비스가 모두 변경되고 배포됩니다.

<br/><br/>

### 마이크로 서비스 통신 패턴
프론트엔드와 백엔드, 백엔드와 백엔드 간의 호출에는 어떤 방법을 사용해야 할까요?  
우선 **동기 통신 방식** 과 **비동기 통신 방식** 으로 나누어 집니다.

- 동기 통신 방식  
    클라이언트에서 서버 측 마이크로 서비스 REST API 를 호출할 때 사용되는 기본 통신 방법입니다.  
    (다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위해 중간에 API 게이트웨이를 둘 수 있습니다)
    
    <br/>
    
    단일 진입점인 API 게이트웨이를 통해 동기 호출하는 구성입니다.
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-call-gateway.png" width="700"/>|
    |-|
    |그림 2 - 프론트엔드에서 백엔드 호출|
    
    <br/>
    
    이처럼 프론트엔드에서 백엔드 서비스 호출에는 동기 호출 방식을 사용하게 됩니다.  
    하지만 백엔드와 백엔드 간의 호출에는 동기 호출 방식이 고려되지 않습니다.  
    그 이유는 호출 중에 장애가 발생할 때 **연쇄적인 장애전파** 가 발생할 수 있기 때문입니다.  
    
    <br/>
    
    동기식 호출은 요청하면 요청에 따른 응답이 오는 방식입니다.  
    직관적인 방식이라 가장 많이 쓰이고 구현하기 쉽지만, 호출 받은 서비스에 장애가 생긴다면 요청 보낸 서비스는 반응이 
    올 때까지 무한정 기다리게 됩니다.  
    
    <br/>
    
    여러 서비스 간의 연계를 통해 업무를 처리해야 하는 마이크로 서비스 구조에서는  
    이 같은 상황에서 장애가 연쇄적으로 발생하게 됩니다.  
    
    <br/>
    
    또한 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는  
    해당 서비스간의 의존관계가 높다는 것을 의미하게 됩니다.  
    (이러한 방식은 독자적인 마이크로 서비스별 비즈니스 기능 처리를 어렵게 만듭니다)  
    
    <br/>
    
    따라서 백엔드와 백엔드 간의 호출에는 장애 파급 효과, 의존 관계를 낮추기 위해 다른 통신 방법을 사용하게 됩니다.
    
<br/>

- 비동기 통신 방식  
    백엔드와 백엔드 간의 호출에는 메시지 기반의 비동기 호출을 사용합니다.  
    이 방식은 동기 호출처럼 응답을 기다리지 않고 다른 다음 일을 처리합니다.  
    (물론 보낸 결과에 대한 완결성을 보장할 수 없습니다)
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-call-async.png" width="600"/>|
    |-|
    |그림 3 - 비동기 통신|
    
    <br/>
    
    이를 보장하기 위한 메커니즘으로 메시지 브로커를 활용하게 됩니다.  
    보통 `Apache Kafka`, `RabbitMQ`, `ActiveMQ` 을 사용하게 됩니다.
    
    <br/>
    
    위 그림에서 볼 수 있듯이 메시지를 보내는 `생산자`와 메시지를 받아 처리하는 `소비자`가  
    직접 접속하지 않고 `메시지 브로커`에 의해 연결되는 메커니즘입니다.  
    메시지 브로커에 메시지를 전달하고 자신의 일을 처리하면 메시지 브로커가 전송을 보장하게 됩니다.
    
    <br/>
    
    메시지 브로커는 메시지 처리 규모에 따라 확장이 가능합니다.  
    또한 서로 통신하는 서비스들이 물리적으로 동일한 시스템에 위치하거나 프로세스를 공유할 필요가 없습니다.  
    따라서 서비스 요구에 따라 늘어나거나 줄어들 수 있는 탄력성 높은 클라우드 플랫폼 환경에서 매우 효과적입니다.
    
<br/><br/>

### 이벤트 기반 아키텍처
위에서 언급한 비동기 통신 방식을 이용해 느슨한 연계를 지향하는 아키텍처입니다.  
- 이벤트를 생성 및 발행하는 발신자 (publisher) 
- 해당 이벤트를 구독하여 이벤트를 받아 처리하는 수신자 (subscriber)
    
여기서 이벤트는 상태의 변화를 의미합니다.  
카페에서의 커피 주문을 예시로 설명해보겠습니다.

<br/>

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-event-driven.png" width="800"/>|
|-|
|그림 4 - 이벤트 기반 아키텍처 개념도|
    
위 방식은 주문 접수 -> 커피 제작 -> 고객 전달이라는 하나의 무결하고 완결된 단위로 진행되지 않습니다.  
주문 접수자는 고객으로부터 주문만 접수하며 커피 주문 이벤트를 발행하여 넘겨주기만 합니다.  
바리스타는 해당 이벤트를 받아 커피만 생산하여 진동벨로 고객에게 완료 이벤트를 넘겨주게 됩니다.  

<br/>

이러한 방식은 여러 개의 주문을 받아 여러 개의 커피를 동시에 제작할 수 있는 효율성을 높입니다.
또한 주문이 많이 들어올 경우 바리스타를 추가 투입하여 생산량을 조절할 수도 있습니다. 

<br/>

이처럼 이벤트 기반 아키텍처는 이벤트를 생산하는 모듈과 이벤트에 대응하는 모듈을 분리하여  
상호 독립적으로 동작하게 함으로써 병렬 처리를 촉진합니다.  
또한 전달 메커니즘으로 앞에서 다룬 비동시 메시지 통신 방식을 선택하면 더욱더 효과적입니다.

<br/>

이벤트 기반 아키텍처 + 비동기 통신 메커니즘을 함께 사용하는 마이크로 서비스를  
**이벤트 기반 마이크로 서비스** 라고 합니다.  

<br/><br/>

### 저장소 분리 패턴
마이크로 서비스를 독립적으로 수정 및 배포하기 위한 저장소의 형태에 대해 알아보겠습니다.

<br/>

기존 모노리식 시스템은 테이터 중심 어플리케이션을 주로 사용하는데,  
모듈별로 격리 하지 않은 통합 저장소를 사용하여 다른 모듈에서의 호출을 허용하는 구조였습니다.  
(이러한 방식은 SQL 조인 구문으로 다른 모듈이 소유권을 가지고 있는 데이터까지 함께 조합하여 호출하게 됩니다)

<br/>

데이터 중심 어플리케이션은 비즈니스 로직이 대부분 데이터베이스 SQL 처리에 몰려잇는 경우가 대부분입니다.  
이러한 구조는 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려워지고  
성능 문제가 발생했을 때 SQL 구문 튜닝이나 저장소 증설에 의존할 수밖에 없습니다.

<br/>

또한 아무리 여러 개의 마이크로 서비스로 분리하더라도 요청이 증가할 경우  
서비스는 한가하고 여러 서비스에서 호출되는 통합 데이터베이스만 바쁜 상황이 되게 됩니다.  

<br/>

이를 보완하는 방법으로 저장소 분리 패턴이 사용됩니다.  
저장소 분리 패턴은 각 서비스가 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유하는 것을 뜻합니다.  
자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API 를 통해서만 접근이 가능하게 됩니다.  

- 정보 은닉  
    공개된 API 를 통해서만 데이터에 접근이 가능
- 폴리글랏 저장소  
    각 저장소를 자율적으로 선택 가능
- 디커플링  
    데이터를 통한 변경의 파급 효과를 줄여 서비스를 독립적으로 만듦
    
<br/>

하지만 저장소를 격리함에 따라 이전에는 불거지지 않았던 문제가 생기게 됩니다.  
즉, 여러개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우  
비즈니스 정합성 및 데이터 일관성을 어떻게 보장할 것인가에 대한 문제입니다.  
이는 분산 트랜잭션 처리 패턴을 통해 일관된 트랜잭션으로 묶을 수 있습니다.

<br/><br/>


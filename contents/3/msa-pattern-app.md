# 마이크로 서비스 어플리케이션 패턴

<br/><br/>



## :speech_balloon: 개요
마이크로 서비스 어플리케이션 영역은 실제로 개발자가 구현해야 할 부분입니다.  
서비스의 비즈니스 로직에 집중할 수 있게

- 유연성
- 확장성
- 독립성 등

을 염두에 두고 설계한 여러 패턴들이 있습니다.

<br/><br/>

### 프론트엔드 연계
우선 하나의 서비스는 보통 프론트엔드와 백엔드의 연계로 구현됩니다.  
만약 프론트엔드가 단일 모노리스로 구성되어있다고 가정한다면,  
MSA 로 구성된 백엔드와의 연계가 매끄럽게 이어지지 않을것입니다.

<br/>

업무 기능 하나가 변경되어 재배포해야 할 상황을 가정해보겠습니다.  
백엔드 부분에서는 수정된 내용이 독립적으로 배포 가능하지만,  
프론트엔드는 하나의 덩어리(모노리스)이기 때문에 변경되지 않은 다른 기능들도 함께 빌드, 배포되어야 합니다.  

<br/>

따라서 이전에 백엔드가 모노리스였을 때 겪었던 문제들
- 독립적인 기능 변경 및 배포 불가
- 독립적인 기능 확장 불가 등

을 프론트엔드의 모노리스 서비스도 동일하게 겪을 수밖에 없습니다.

<br/>

이를 위한 프론트엔드 설계 패턴으로 다음이 있습니다.
- UI 컴포지드 패턴
- 마이크로 프론트엔드 패턴

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-fe.png" width="700"/>|
|-|
|그림 1 - 독립된 팀에서 별도로 관리하는 프론트엔드|

그림 1 과 같이 프론트엔드도 백엔드의 마이크로 서비스처럼 기능별로 분리하고  
이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프론트엔드를 조합해서 동작됩니다.  

<br/>

각각의 마이크로 프론트엔드 조각들은 비즈니스 구현을 위해 여러 개의 백엔드 마이크로 서비스 API 를 호출하게 됩니다.  
하나의 기능을 변경했을 때 이를 제공하는 마이크로 프론트엔드와 백엔드를 구성하는 마이크로 서비스가 모두 변경되고 배포됩니다.

<br/><br/>

### 마이크로 서비스 통신 패턴
프론트엔드와 백엔드, 백엔드와 백엔드 간의 호출에는 어떤 방법을 사용해야 할까요?  
우선 **동기 통신 방식** 과 **비동기 통신 방식** 으로 나누어 집니다.

- 동기 통신 방식  
    클라이언트에서 서버 측 마이크로 서비스 REST API 를 호출할 때 사용되는 기본 통신 방법입니다.  
    (다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위해 중간에 API 게이트웨이를 둘 수 있습니다)
    
    <br/>
    
    단일 진입점인 API 게이트웨이를 통해 동기 호출하는 구성입니다.
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-call-gateway.png" width="700"/>|
    |-|
    |그림 2 - 프론트엔드에서 백엔드 호출|
    
    <br/>
    
    이처럼 프론트엔드에서 백엔드 서비스 호출에는 동기 호출 방식을 사용하게 됩니다.  
    하지만 백엔드와 백엔드 간의 호출에는 동기 호출 방식이 고려되지 않습니다.  
    그 이유는 호출 중에 장애가 발생할 때 **연쇄적인 장애전파** 가 발생할 수 있기 때문입니다.  
    
    <br/>
    
    동기식 호출은 요청하면 요청에 따른 응답이 오는 방식입니다.  
    직관적인 방식이라 가장 많이 쓰이고 구현하기 쉽지만, 호출 받은 서비스에 장애가 생긴다면 요청 보낸 서비스는 반응이 
    올 때까지 무한정 기다리게 됩니다.  
    
    <br/>
    
    여러 서비스 간의 연계를 통해 업무를 처리해야 하는 마이크로 서비스 구조에서는  
    이 같은 상황에서 장애가 연쇄적으로 발생하게 됩니다.  
    
    <br/>
    
    또한 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는  
    해당 서비스간의 의존관계가 높다는 것을 의미하게 됩니다.  
    (이러한 방식은 독자적인 마이크로 서비스별 비즈니스 기능 처리를 어렵게 만듭니다)  
    
    <br/>
    
    따라서 백엔드와 백엔드 간의 호출에는 장애 파급 효과, 의존 관계를 낮추기 위해 다른 통신 방법을 사용하게 됩니다.
    
<br/>

- 비동기 통신 방식  
    백엔드와 백엔드 간의 호출에는 메시지 기반의 비동기 호출을 사용합니다.  
    이 방식은 동기 호출처럼 응답을 기다리지 않고 다른 다음 일을 처리합니다.  
    (물론 보낸 결과에 대한 완결성을 보장할 수 없습니다)
    
    |<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-call-async.png" width="600"/>|
    |-|
    |그림 3 - 비동기 통신|
    
    <br/>
    
    이를 보장하기 위한 메커니즘으로 메시지 브로커를 활용하게 됩니다.  
    보통 `Apache Kafka`, `RabbitMQ`, `ActiveMQ` 을 사용하게 됩니다.
    
    <br/>
    
    위 그림에서 볼 수 있듯이 메시지를 보내는 `생산자`와 메시지를 받아 처리하는 `소비자`가  
    직접 접속하지 않고 `메시지 브로커`에 의해 연결되는 메커니즘입니다.  
    메시지 브로커에 메시지를 전달하고 자신의 일을 처리하면 메시지 브로커가 전송을 보장하게 됩니다.
    
    <br/>
    
    메시지 브로커는 메시지 처리 규모에 따라 확장이 가능합니다.  
    또한 서로 통신하는 서비스들이 물리적으로 동일한 시스템에 위치하거나 프로세스를 공유할 필요가 없습니다.  
    따라서 서비스 요구에 따라 늘어나거나 줄어들 수 있는 탄력성 높은 클라우드 플랫폼 환경에서 매우 효과적입니다.
    
<br/><br/>

### 이벤트 기반 아키텍처
위에서 언급한 비동기 통신 방식을 이용해 느슨한 연계를 지향하는 아키텍처입니다.  
- 이벤트를 생성 및 발행하는 발신자 (publisher) 
- 해당 이벤트를 구독하여 이벤트를 받아 처리하는 수신자 (subscriber)
    
여기서 이벤트는 상태의 변화를 의미합니다.  
카페에서의 커피 주문을 예시로 설명해보겠습니다.

<br/>

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-event-driven2.png" width="700"/>|
|-|
|그림 4 - 이벤트 기반 아키텍처 개념도|
    
위 방식은 주문 접수 -> 커피 제작 -> 고객 전달이라는 하나의 무결하고 완결된 단위로 진행되지 않습니다.  
주문 접수자는 고객으로부터 주문만 접수하며 커피 주문 이벤트를 발행하여 넘겨주기만 합니다.  
바리스타는 해당 이벤트를 받아 커피만 생산하여 진동벨로 고객에게 완료 이벤트를 넘겨주게 됩니다.  

<br/>

이러한 방식은 여러 개의 주문을 받아 여러 개의 커피를 동시에 제작할 수 있는 효율성을 높입니다.  
또한 주문이 많이 들어올 경우 바리스타를 추가 투입하여 생산량을 조절할 수도 있습니다. 

<br/>

이처럼 이벤트 기반 아키텍처는 이벤트를 생산하는 모듈과 이벤트에 대응하는 모듈을 분리하여  
상호 독립적으로 동작하게 함으로써 병렬 처리를 촉진합니다.  
또한 전달 메커니즘으로 앞에서 다룬 비동시 메시지 통신 방식을 선택하면 더욱더 효과적입니다.

<br/>

이벤트 기반 아키텍처 + 비동기 통신 메커니즘을 함께 사용하는 마이크로 서비스를  
**이벤트 기반 마이크로 서비스** 라고 합니다.  

<br/><br/>

### 저장소 분리 패턴
마이크로 서비스를 독립적으로 수정 및 배포하기 위한 저장소의 형태에 대해 알아보겠습니다.

<br/>

기존 모노리식 시스템은 테이터 중심 어플리케이션을 주로 사용하는데,  
모듈별로 격리 하지 않은 통합 저장소를 사용하여 다른 모듈에서의 호출을 허용하는 구조였습니다.  
(이러한 방식은 SQL 조인 구문으로 다른 모듈이 소유권을 가지고 있는 데이터까지 함께 조합하여 호출하게 됩니다)

<br/>

데이터 중심 어플리케이션은 비즈니스 로직이 대부분 데이터베이스 SQL 처리에 몰려잇는 경우가 대부분입니다.  
이러한 구조는 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려워지고  
성능 문제가 발생했을 때 SQL 구문 튜닝이나 저장소 증설에 의존할 수밖에 없습니다.

<br/>

또한 아무리 여러 개의 마이크로 서비스로 분리하더라도 요청이 증가할 경우  
서비스는 한가하고 여러 서비스에서 호출되는 통합 데이터베이스만 바쁜 상황이 되게 됩니다.  

<br/>

이를 보완하는 방법으로 저장소 분리 패턴이 사용됩니다.  
저장소 분리 패턴은 각 서비스가 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유하는 것을 뜻합니다.  
자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API 를 통해서만 접근이 가능하게 됩니다.  

- 정보 은닉  
    공개된 API 를 통해서만 데이터에 접근이 가능
- 폴리글랏 저장소  
    각 저장소를 자율적으로 선택 가능
- 디커플링  
    데이터를 통한 변경의 파급 효과를 줄여 서비스를 독립적으로 만듦
    
<br/>

하지만 저장소를 격리함에 따라 이전에는 불거지지 않았던 문제가 생기게 됩니다.  
즉, 여러개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우  
비즈니스 정합성 및 데이터 일관성을 어떻게 보장할 것인가에 대한 문제입니다.  
이는 분산 트랜잭션 처리 패턴을 통해 일관된 트랜잭션으로 묶을 수 있습니다.

<br/><br/>

### 분산 트랜잭션 처리 패턴 
여러 개의 분산된 서비스를 하나의 일관된 트랜젝션으로 묶기 위해 분산 트랜잭션 처리 패턴을 사용하게 됩니다.  

<br/>

전통적인 방법으로 2단계 커밋 같은 기법이 있습니다.  
분산 데이터베이스 환경에서 원자성을 보장하기 위해  
분산 트랜잭션에 포함돼 있는 모든 노드가 커밋 되거나 롤백 하는 메커니즘입니다.

<br/>

하지만 이 방법은 각 서비스에 잠금(lock in)이 걸려 발생하는 성능 문제를 야기해 효율적인 방법이 아닙니다.  
특히 각 서비스가 다른 인스턴스로 로딩되기 때문에 통제하기 어렵습니다.  
또한 MongoDB 같은 NoSQL 저장소는 해당 방식을 지원하지 않습니다.  

<br/>

클라우드의 가장 큰 장애는 네트워크 장애인 경우가 많은데, 특정 서비스의 트랜잭션이 처리되지 않을 경우  
트랜잭션에 묶인 서비스가 즉시 영향을 받게 됩니다.  
즉, 2단계 커밋 기법을 통한 분산 트랜잭션 처리는 독립적이지 않고 비자율적입니다.

<br/>

마이크로 서비스의 독립적인 분산 트랜잭션 처리를 지원하는 패턴이 바로 `사가(Saga) 패턴`입니다.  
사가 패턴은 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴입니다.  
로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터의 정합성을 맞춥니다.  
다른 트랜잭션의 결과에 따라 롤백이 필요하다면 보상 트랜잭션을 이용하여 롤백 처리를 하게 됩니다.  

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-saga.png" width="700"/>|
|-|
|그림 5 - 분산 트랜잭션과 사가 패턴|

<br/>

쉽게 말해 각 서비스의 트랜잭션을 로컬 트랜잭션으로 분리하고 이벤트 패턴을 통해 결과를 통신하는 방식입니다.  
다음은 사가 패턴의 사례입니다.  

> 사가 편성 방식은 코레오그레피 사가 방식과 오케스트레이션 사가 방식 두 종류로 나뉘며, 아래 사례는 코레오그레피 사가 방식입니다.  
> 코레오그레피 방식은 의사결정과 순서를 참가자에게 맡기고 주로 이벤트 교환 방식으로 통신하며,  
> 오케스트레이션 방식은 사가 오케스트레이터가 참여자에게 커멘드 메시지를 보내 수행할 작업을 지시하는 방식입니다.

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-saga-ex1.png" width="900"/>|
|-|
|그림 6 - 사가 패턴 사례|

<br/><br/>

#### 결과적 일관성
모든 어플리케이션에는 비즈니스 처리를 위한 규칙이 있고, 이러한 규칙을 만족하도록 데이터 일관성이 유지되어야 합니다.  
이전까지는 이 데이터 일관성이 실시간으로 반드시 맞아야 한다는 생각이 일반적이었습니다.  

<br/>

만약 서비스에 트래픽이 폭주한 경우를 생각해보면, 순차적인 동시 일관성을 추구하는 경우  
어느 한 서비스에서 장애가 발생하게 되고 결국 지연 또는 장애 전파가 발생할 수 밖에 없습니다.  

<br/>

잘 생각해 보면 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것이 아닙니다.  
어떤 비즈니스는 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시점이 됐을 때 일관성을 만족해도 되는 것이 있습니다.  
이러한 개념을 결과적 일관성이라 합니다.

<br/>

결과적 일관성은 고가용성을 극대화합니다.  
이 또한 사가 패턴과 이벤트 메시지 기반 비동기 통신을 적용하여 구현할 수 있습니다.  
(각 서비스의 트랜잭션은 독립적이고 각 트랜잭션이 성공했을 때 상태 변경 이벤트를 통해 타 서비스와 연계됩니다)

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-saga-ex2.png" width="1000"/>|
|-|
|그림 7 - 비동기 통신과 사가 패턴 적용 사례|

이처럼 `이벤트 기반 아키텍처`, `메시지 브로커`, `사가 패턴`으로 비즈니스 정합성을 결과적으로 보장할 수 있고  
비즈니스 및 시스템 가용성을 극대화할 수 있습니다.

<br/><br/>

### CQRS 패턴 (읽기와 쓰기 분리)
서비스별로 데이터 저장소를 나누어 놓아도 전통적인 DB 트랜젝션을 사용한다면 문제가 발생하게 됩니다.  
인스턴스를 스케일 아웃하여 여러 데이터 처리를 할 경우 여러 읽기/수정 작업으로 인한 리소스 교착상태가 발생할 수 있습니다.  

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-transaction1.png" width="400"/>|
|-|
|그림 8 - CRUD 기능이 모두 있는 마이크로 서비스|

<br/>

위 문제를 해결하기 위해 CQRS 패턴을 사용합니다.
CQRS 패턴은 Command Query Responsibility Segregation, 즉 명령과 조회의 (책임) 분리를 의미합니다.  

<br/>

일반적으로 사용자의 비즈니스 요청은 (시스템의 상태를 변경하는) 명령과 (시스템의 상태를 나타내는) 조회로 나눌 수 있습니다.  
하지만 실제 업무에서는 조회하는 부분이 많이 쓰이게 됩니다. \[ 조회 > 입력, 수정, 삭제 \]  
서비스 내에 이러한 CRUD 기능을 모두 넣어두면 조회 요청 빈도가 증가함에 따라 나머지 명령 기능은 비효율적일 수 밖에 없습니다.

<br/>

조회와 명령, 두 서비스의 분리뿐만 아니라 물리적인 저장소를 따로 나누어 시스템의 부하를 줄일 수도 있습니다.

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-cqrs1.png" width="900"/>|
|-|
|그림 9 - 쓰기와 읽기를 분리하는 과정|

<br/>

이 CQRS 패턴을 이벤트 메시지 주도 아키텍처와 연계한 예시 모습입니다.

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-cqrs2.png" width="1000"/>|
|-|
|그림 10 - CQRS 패턴과 Event Driven Architecture|

예시에 대한 설명입니다.

- 명령 측면 서비스에는 입력, 수정, 삭제 처리등 쓰기에 최적화된 관계형 데이터베이스를 사용합니다.
- 명령 서비스를 구현하는 프로그래밍 또한 업무 규칙을 표현하기 좋은 자바 언어를 사용합니다.
- 조회 측면 서비스에는 조회 성능이 높은 몽고디비나 엘라스틱서치 같은 NoSQL 데이터베이스를 사용합니다.
- 조회 서비스를 구현하는 프로그래밍은 조회를 간단하게 구현할 수 있는 스크립트 기반의 Node.js 를 사용합니다.
- 상대적으로 사용량이 많은 조회 서비스는 스케일 아웃하여 인스턴스를 증가시킬 수 있습니다.
- 두 서비스의 데이터 일관성을 유지하기 위해 이벤트를 발생시켜 메시지 브로커를 통해 데이터를 전달 받아 동기화 시킵니다.
- 실시간으로 데이터의 동기화가 이루어 지진않지만, 어느 시점이 되면 결과적으로 일치하게 되는 결과적 일관성을 추구합니다.

<br/><br/>

### API 조합과 CQRS
각기 다른 서비스들의 기능을 연계해서 하나의 기능을 제공하는 경우에는 어떻게 해야 할까요.

<br/>

첫 번째 방법은 API 조합입니다.  

|<img src="https://github.com/cholnh/delivery-platform-server-guide/blob/main/assets/images/3/msa-pattern-app-api-comp.png" width="600"/>|
|-|
|그림 11 - API 조합|

위 예시 그림과 같이 `주문 이력 서비스`는 `제품`, `주문`, `고객`, `배송` 서비스의 정보가 모두 필요합니다.  
각 기능을 제공하는 서비스를 조합하는 상위 마이크로 서비스를 만들어 조합된 기능을 제공할 수 있습니다.  

